## Load Packages ##
x<-c("ggplot2", "VennDiagram",  "pheatmap", "ggfortify", "cluster", "DESeq2", "edgeR", "baySeq", "readxl", "reshape2",  "gplots", "RColorBrewer", "EnhancedVolcano", "umap", "patchwork")
invisible(suppressMessages(lapply(x, require, character.only = TRUE)))

## UTILITIES

#' Return z-score standardized values
#'
#' This function takes in a numerical vector or matrix. It calculates and returns the z-score standardized value of each element. 
#' 
#'
#' @param x input vector or matrix
#' @return z-score standardized input
#' @export

zscorestandardize<-function(x)
{
  if(is.numeric(x)){
   (x- mean(x)) /sd(x)
   } else {
    stop('non numeric values!')
   }
}

.removeOutliers<-function(data, design, Z_max=3)
{
replicates<-.findreplicates(design)
design<-design[order(replicates),,drop=FALSE]
data<-data[,rownames(design)]
rep_rm<-data.frame(replicates, colSums(data))
rownames(rep_rm)<-rownames(design)
replicates<-unique(replicates)
Z<-c()
for(i in 1:length(replicates)){
xm<-median(rep_rm[which(rep_rm[,1]==replicates[i]),2])
mad<-median(abs(rep_rm[which(rep_rm[,1]==replicates[i]),2]-xm))
mnad<-mean(abs(rep_rm[which(rep_rm[,1]==replicates[i]),2]-xm))
if(mad==0){
if(mnad==0){
  Z<-c(Z,rep(0, length(rep_rm[which(rep_rm[,1]==replicates[i]),2])))
} else {
  Z<-c(Z,(rep_rm[which(rep_rm[,1]==replicates[i]),2]-xm)/I(1.253314*mnad))
}
} else {
Z<-c(Z,0.675*(rep_rm[which(rep_rm[,1]==replicates[i]),2]-xm)/mad)
}
}
k<-c()
for(i in 1:length(Z)){
if(abs(Z[i])>Z_max){
if((mean(rep_rm[which(rep_rm$replicates==rep_rm$replicates[i]),2])-rep_rm[i,2])>0.25*mean(rep_rm[which(rep_rm$replicates==rep_rm$replicates[i]),2])){
k<-c(k,i)
}
}
}
if(length(k)>0){
design<-design[-k,, drop=FALSE]
}
data<-data[,rownames(design)]
list(data,design)
}

#' Preprocess data for Record-seq analysis
#'
#' This function takes in a counts matrix, a design matrix, and (optional) a matrix of cumulative counts per sample.  
#' It filters and sorts samples in the counts matrices based on the design matrix. Further, it removes samples with a 
#' cumulative count below minCountsPerSample, and filters lowly expressed genes in the lowest quartile. It outputs a 
#' list, where the first element is the pre-processed counts matrix, second element is the design matrix, and third (optional)
#' is the processed cumulative counts matrix. 
#' @param data input counts matrix as data frame; rows = genes, cols = samples
#' @param design input design matrix as data frame; rows = samples, cols = design factors
#' @param totalCounts input cumulative counts matrix as data frame; rows = samples, cols = type of counts
#' @param minCountsPerSample minimum cumulative counts per sample
#' @return list of pre-processed files
#' @export

recoRdseq.preprocess <- function(data, design, totalCounts, minCountsPerSample=1000) {
rownames(data)<-data[,1]
data<-data[,-c(1:6)]
rownames(design)<-as.character(design[,1])
design<-design[,-1, drop=FALSE]
for(i in 1:length(rownames(design))){
  colnames(data)[which(grepl(paste0("_",rownames(design)[i],"_"), colnames(data)))]<-rownames(design)[i]
}
data<-data[which(rowSums(data)>as.numeric(quantile(rowSums(data))[2])),]
data<-data[,rownames(design)]
idx <- which(colSums(data)<minCountsPerSample)
if (length(idx)>0) {
  design<-design[-idx, ,drop=FALSE]
  data<-data[,-idx]
}
DEList<-.removeOutliers(data, design)
if(!missing(totalCounts)){
  design<-DEList[[2]]
  totalCounts<-totalCounts[rownames(design),]
  DEList<-list(data, design, totalCounts)
}
DEList
}

#' Find differentially expressed genes using Record-seq data
#'
#' This function takes in a counts matrix, a design matrix, (optional) a designFormula and a differential expression (DE) tool.  
#' It outputs a data frame with the logFC and p-adj value for differential expression for each gene generated by the DE tool.
#' @param data input counts matrix as data frame; rows = genes, cols = samples
#' @param design input design matrix as data frame; rows = samples, cols = design factors
#' @param designFormula any permitted combination of design factors in the design matrix, starting with "~", eg: "~Treatment+Time"
#' @param tool package for Differential expression. can be 'DESeq2', 'edgeR' or 'baySeq'
#' @return data frame of genes with differential expression information
#' @export

recoRdseq.DE <- function(data, design, designFormula, tool="DESeq2")
{
  if(tool=='DESeq2'){
    out<-.deseq(data, design, designFormula, output="result")
  }
  else if(tool=='edgeR'){
    out<-.edger(data, design, designFormula, output="result")
  }
  else if(tool=='baySeq'){
    replicates<-.findreplicates(design)
    out<-.bayseq(data, replicates, design)
  }
  else{
    stop("invalid DE tool choice!")
  }
}

#' Normalize and transform Record-seq counts data
#'
#' This function takes in a counts matrix, a design matrix, and a transformation.  
#' It outputs a transformed counts matrix using the specified transformation.
#' @param data input counts matrix as data frame; rows = genes, cols = samples
#' @param design input design matrix as data frame; rows = samples, cols = design factors
#' @param transformation "log2" (general log2-transformation), "rlog" (regularized log from DESeq2), "vst" (variance stabilizing transform from DESeq2), "tmm" (trimmed mean of m normalization followed by log2 transform), "thinCounts" (downsampling followed by log2 transform)
#' @return transformed counts matrix
#' @export

recoRdseq.transform <- function(data, design, transformation='vst')
{
  if (transformation=="log2"){
    # log2 table of counts data
    data_transformed <- as.data.frame(apply(data, c(1,2), function(x) log2(x+1)))
  } else if (transformation=="rlog"){
    data_transformed <- .deseq(data, design, output = "rlog")
  } else if (transformation=="vst"){
    data_transformed <- .deseq(data, design, output = "vst")
  } else if (transformation=="tmm"){
    data_transformed <- .edger(data, design, output = "tmm")
    data_transformed <- as.data.frame(apply(data_transformed, c(1,2), function(x) log2(x+1)))
  } else if (transformation=="thinCounts"){
    minLibSize <- min(colSums(data, na.rm = FALSE, dims = 1), na.rm = FALSE)
    data_transformed <- thinCounts(data, prob=NULL, target.size=minLibSize)
    data_transformed <- as.data.frame(apply(data_transformed, c(1,2), function(x) log2(x+1)))
  }
  data_transformed
}

.deseq<-function(data, design, designFormula, output="result") ## output can also be "rlog" for rlog transformed counts
{
data<-apply(data, c(1,2), round)
colData<-data.frame(row.names = rownames(design))
for (i in 1:dim(design)[2]) {
  colData[,i]<-as.factor(design[,i])
}
colnames(colData)<-colnames(design)
if (missing(designFormula)){
  if(length(colnames(colData))==1){
  designFormula=paste0("~", colnames(colData))
  } else {
  designFormula=paste0("~", colnames(colData)[1])
  }
}
dds <- DESeqDataSetFromMatrix(countData = data,colData = colData,design = formula(designFormula) )
if(dim(design)[2]==1 & length(unique(design[,1]))==2){
  dds <- DESeq(dds) ## Wald test for pairwise
} else {
  dds <- DESeq(dds, test="LRT", reduced=~1) ## Likelihood ratio test for multiple groups/factors
}
if(output=="result"){
  res <- results(dds)
  res <- res[order(res$padj),]
  b<-match(rownames(res),rownames(data))
  out<-data.frame(geneID=rownames(res),order=b, res)
  out
} else if(output=="rlog"){
  rld <- rlog(dds, blind=FALSE)
  data_tf<-as.data.frame(assay(rld))
  data_tf
} else if(output=="vst"){
  vsd<-varianceStabilizingTransformation(dds, blind = FALSE)
  data_tf<-as.data.frame(assay(vsd))
  data_tf
}
}

.bayseq<-function(data, replicates, design){
  groups <- list(NDE = c(rep(1,dim(design)[1])))
  groups[[colnames(design)[1]]]= design[,1]
  genenames<-rownames(data)
  data=as.matrix(data)
  rownames(data)<-1:length(rownames(data))
  cD <- new("countData", data = data, replicates = replicates, groups = groups)
  libsizes(cD) <- getLibsizes(cD)
  cD <- getPriors.NB(cD,  samplesize = 1000, cl = NULL)
  cD <- getLikelihoods(cD)
  cD@annotation <- data.frame(annotation = genenames)
  res<-topCounts(cD,group= colnames(design)[1],number=nrow(data))
  sizes<-as.numeric(libsizes(cD)/median(libsizes(cD)))
  baseMean<-rowMeans(t(t(data)/sizes))
  class<-unique(design[,1])
  log2FC<-rowMeans(t(t(data[,which(design[,1]==class[2])])/sizes[which(design[,1]==class[2])]))/rowMeans(t(t(data[,which(design[,1]==class[1])])/sizes[which(design[,1]==class[1])])) #reports log2FC of the first two classes by default
  out<-data.frame(geneID=res$annotation,order=rownames(res),baseMean=baseMean,log2FC=log2FC,padj=res[,dim(res)[2]-1], res[,c((dim(res)[2]-3):dim(res)[2])])
  out
}

.edger<-function(data, design, designFormula, output="result")
{
colData<-data.frame(row.names = rownames(design))
for (i in 1:dim(design)[2]) {
  colData[,i]<-as.factor(design[,i])
}
colnames(colData)<-colnames(design)
if (missing(designFormula)) {
  if(length(colnames(colData))==1){
    designFormulaMatrix<-model.matrix(formula(paste0("~", colnames(colData))), colData)
    } else {
      designFormulaMatrix<-model.matrix(formula(paste0("~", colnames(colData)[1])), colData)
    }
} else {
  designFormulaMatrix<-model.matrix(formula(designFormula), colData)
}
y <- DGEList(data)
y <- calcNormFactors(y, method = "TMMwzp")
if(output=="result"){
  if(dim(design)[2]==1 & length(unique(design[,1]))==2){ ## exact test for pairwise
    y <- estimateDisp(y, designFormulaMatrix)
    fit <- glmQLFit(y,designFormulaMatrix)
    qlf <- glmQLFTest(fit,coef=2)
    qlf <- qlf$table
  } else {
    y <- estimateDisp(y, designFormulaMatrix) ## GLM for multi-group/factor
    fit <- glmQLFit(y, designFormulaMatrix)
    qlf <- glmQLFTest(fit, coef=2:length(colnames(designFormulaMatrix)))
    qlf <- qlf$table
  }
  padj<-p.adjust(qlf$PValue,method='BH')
  qlf<-data.frame(qlf,padj)
  oe <- order(qlf[,"padj"])
  res<-qlf[oe,]
  baseMean<-rowMeans(t(t(data)/y$samples$norm.factors))
  b<-match(rownames(res),rownames(data))
  out<-data.frame(geneID=rownames(res),order=b,baseMean=baseMean[b], res)
  out
} else if (output=="tmm"){
  tmm <- as.data.frame(cpm(y))
  tmm
}
}

.save_pheatmap_pdf <- function(heatmap, filename) {
pdf(filename)
grid::grid.newpage()
grid::grid.draw(heatmap$gtable)
dev.off()
}

#' Filter top DE genes based on output of recoRdseq.DE function
#'
#' This function takes in the data frame generated by the recoRdseq.DE function, and filters genes based on p-adjusted value
#' @param genesDE data frame of genes with DE values generated by the recoRdseq.DE function
#' @param p maximum p-adj value
#' @param n maximum number of output genes (overrides p)
#' @return vector of DE genes
#' @export
recoRdseq.filterDEG <- function(genesDE,p=0.05, n=NULL)
{
if(is.null(n)){
  ord <- which(genesDE$padj<p)
  as.character(genesDE$geneID[ord])
} else {
  ord <- order(genesDE$padj)
  as.character(genesDE$geneID[ord[1:n] ])
}
}

.ggplot2Col <- function(n){
h = c(15,375)
if ((diff(h) %% 360) < 1) h[2] <- h[2] - 360/n
hcl(h = (seq(h[1], h[2], length = n)), c = 100, l = 65)
}

.findreplicates <- function(design){
  if(ncol(design>1)){
    design_collapsed<-as.vector(apply( design , 1 , paste0 , collapse = "" ))
  } else {
    design_collapsed<-as.vector(design[,1])
  }
  mapdesign<-data.frame(d=unique(design_collapsed), n=1:length(unique(design_collapsed)))
  replicates<-mapdesign$n[match(design_collapsed,mapdesign$d)]
}


## NatProt functions

#' Perform Record-seq secondary analysis
#'
#' This function implements the complete Record-seq analysis pipeline. It takes paths of files generated by 
#' Record-seq primary analysis as input, and generates all output files at desired output path. 
#' @param countsMatrix path to featureCounts output counts matrix
#' @param designMatrix path to design matrix
#' @param outPath path for saving output files
#' @export

recoRdSeqAnalysis  <- function(
countsMatrix,  # path to featurecounts output
designMatrix, #  path to designMatrix
outPath, # path for output
totalCountsFile = NULL,
designFormula =  NA,
nGenes = 50, # no of top genes for gene box plots (counts) and PCA (variance)
K = 2, # initialization value for K-means/ FANNY clustering
minCountsPerSample = 500, # minimum number of total counts in a sample or it is excluded from analysis
geneBoxAndWhiskerPlots = TRUE,
transformation = "rlog", # Data transformation prior to plotting gene count boxplots and PCA - can be "log2", "rlog", "vst", "tmm" or NULL
clustering = FALSE,
PCAplots = TRUE,
vennDiagrams = TRUE
)
{
data <- as.data.frame(read.table(countsMatrix, header = TRUE))
for(i in 7:dim(data)[2]){
  colnames(data)[i]<-strsplit(colnames(data)[i], "/")[[1]][length(strsplit(colnames(data)[i], "/")[[1]])]
  colnames(data)[i]<-gsub(".bam", "", colnames(data)[i])
}
no=nGenes

# Read in design matrix
design <- as.data.frame(read_excel(designMatrix))
if(!dir.exists(outPath)){dir.create(outPath)}

# Read in total counts by sample
if(!is.null(totalCountsFile)){
  totalCounts <- as.data.frame(read.table(totalCountsFile, header = TRUE))
  DEList<-recoRdseq.preprocess(data=data, design=design, totalCounts=totalCounts, minCountsPerSample=minCountsPerSample)
} else {
  DEList<-recoRdseq.preprocess(data=data, design=design, totalCounts=NULL, minCountsPerSample=minCountsPerSample)
}
data<-as.data.frame(DEList[[1]])
design<-as.data.frame(DEList[[2]])
# DEList<-.removeOutliers(data, design)
if(!is.null(totalCountsFile)){
  totalCounts<-as.data.frame(DEList[[3]])
}

.DEStats(DEList, outPath, designFormula, K=K, geneBoxAndWhiskerPlots=geneBoxAndWhiskerPlots, totalCountsFile, PCAplots=PCAplots, clustering=clustering, vennDiagrams=vennDiagrams, no=no, transformation = transformation)
  
}

theme_pub<-theme_minimal()+
theme(legend.position="bottom", legend.justification="center", legend.margin=margin(0,0,0,0),legend.box.margin=margin(-10,-10,-10,-10), legend.spacing.y =  unit(0, 'mm'), legend.box='vertical', legend.key.size = unit(0.1, "cm"),legend.key.width = unit(0.1,"cm"), legend.text=element_text(size=8), text = element_text(size=8), panel.grid.minor = element_blank(), axis.text = element_text(size=8, colour='black'), panel.grid.major = element_line(size = 0.24, colour='gray1', linetype = 2))


.PlotCounts <- function(totalCounts, design){
if(rownames(totalCounts)==rownames(design)){
  totalCounts$samples<-factor(rownames(totalCounts), rownames(totalCounts))
  design$samples<-factor(rownames(design), rownames(design))
  CountsPlots<-merge(totalCounts, design, by="samples")
}
CountsPlots_figures<-list()
CountsPlots_figures[[1]]<-ggplot(CountsPlots, aes(y=genomeCounts, x=samples,fill=as.character(CountsPlots[,5])))+
  geom_bar(stat="summary", , funy='mean', width=0.3)+
  coord_cartesian(ylim = c(0, 1.2*max(CountsPlots$genomeCounts))) + theme_pub+plot_annotation()+
  xlab("Samples")+ ylab("Mean genome-mapping spacer counts")+theme(axis.text.x = element_text(angle = 90, hjust = 1))
CountsPlots_figures[[2]]<-ggplot(CountsPlots, aes(y=plasmidCounts, x=samples,fill=as.character(CountsPlots[,5])))+
  geom_bar(stat="summary", , funy='mean', width=0.3)+
  coord_cartesian(ylim = c(0, 1.2*max(CountsPlots$plasmidCounts))) + theme_pub+plot_annotation()+
  xlab("Samples")+ ylab("Mean plasmid-mapping spacer counts")+theme(axis.text.x = element_text(angle = 90, hjust = 1))
CountsPlots_figures
## For calculating mean counts and plotting with SEs ##
# CountsPlots <-data.frame(unique(design))
# colnames(CountsPlots)<-colnames(design)
# MeanGenomeCounts<-c()
# GenomeCountSEs<-c() #SE = standard error
# MeanPlasmidCounts<-c()
# PlasmidCountSEs<-c()
# 
# for(k in 1:dim(CountsPlots)[1]) {
#   MeanGenomeCounts<-c(MeanGenomeCounts, mean(totalCounts$genomeCounts[which(design[,1]==CountsPlots[k,1])]))
#   GenomeCountSEs<-c(GenomeCountSEs, sd(totalCounts$genomeCounts[which(design[,1]==CountsPlots[k,1])])/sqrt(length(which(design[,1]==CountsPlots[k,1]))))
#   MeanPlasmidCounts<-c(MeanPlasmidCounts, mean(totalCounts$plasmidCounts[which(design[,1]==CountsPlots[k,1])]))
#   PlasmidCountSEs<-c(PlasmidCountSEs, sd(totalCounts$plasmidCounts[which(design[,1]==CountsPlots[k,1])])/sqrt(length(which(design[,1]==CountsPlots[k,1]))))
#   }
# 
# CountsPlots<-cbind(CountsPlots, MeanGenomeCounts, MeanPlasmidCounts, GenomeCountSEs, PlasmidCountSEs)
# CountsPlots[is.na(CountsPlots)]=0
# 
# CountsPlots_figures<-list()
# CountsPlots_figures[[1]]<-ggplot(CountsPlots, aes(y=MeanGenomeCounts, x=as.character(CountsPlots[,1])))+
#   geom_bar(stat="identity", width=0.3, fill="deepskyblue3")+
#   coord_cartesian(ylim = c(0, 1.5*max(CountsPlots$MeanGenomeCounts))) + theme_pub+plot_annotation()+
#   geom_errorbar(ymin=MeanGenomeCounts-GenomeCountSEs, ymax=MeanGenomeCounts+GenomeCountSEs,linetype=5, width = 0.1, color="darkblue")+
#   xlab(colnames(design)[1])+ ylab("Mean genome-mapping spacer counts")
# CountsPlots_figures[[2]]<-ggplot(CountsPlots, aes(y=MeanPlasmidCounts, x=as.character(CountsPlots[,1])))+
#   geom_bar(stat="identity", width=0.3, fill="deepskyblue3")+
#   coord_cartesian(ylim = c(0, 1.5*max(CountsPlots$MeanPlasmidCounts))) + theme_pub+plot_annotation()+ ylab("Mean plasmid-mapping spacer counts")+
#   geom_errorbar(ymin=MeanPlasmidCounts-PlasmidCountSEs, ymax=MeanPlasmidCounts+PlasmidCountSEs,linetype=5, width = 0.1, color="darkblue" )+
#   xlab(colnames(design)[1])
# CountsPlots_figures
}

.DEStats <- function(DEList, outPath, designFormula, K, vennDiagrams, geneBoxAndWhiskerPlots=TRUE, totalCountsFile, PCAplots=TRUE, clustering=TRUE, no=no, transformation) {         # formula to be used for Differential Expression.
#If designFormula is null, all columns in the design matrix will be individually used as classes.
#If supplied, only this formula will be used

data<-as.data.frame(DEList[[1]])
design<-as.data.frame(DEList[[2]])
if(!is.null(totalCountsFile)){
  totalCounts<-as.data.frame(DEList[[3]])
}


union_de <- list()
union_de_pval <-list()
intersect_DE <- list()

# creating a vector of replicates

replicates<-.findreplicates(design)


## SCRIPT PARSES THROUGH EACH COLUMN OF DESIGN MATRIX ##

for(i in 1:length(colnames(design))) {

  if (is.null(transformation)){
    data_transformed <- data
  } else if (transformation=="log2"){
    # log2 table of counts data
    data_transformed <- as.data.frame(apply(data, c(1,2), function(x) log2(x+1)))
  } else if (transformation=="rlog"){
    data_transformed <- .deseq(data, design[,i, drop=FALSE], output = "rlog")
  } else if (transformation=="vst"){
    data_transformed <- .deseq(data, design[,i, drop=FALSE], output = "vst")
  } else if (transformation=="tmm"){
    data_transformed <- .edger(data, design[,i, drop=FALSE], output = "tmm")
    data_transformed <- as.data.frame(apply(data_transformed, c(1,2), function(x) log2(x+1)))
  } else if (transformation=="thinCounts"){
    minLibSize <- min(colSums(data, na.rm = FALSE, dims = 1), na.rm = FALSE)
    data_transformed <- thinCounts(data, prob=NULL, target.size=minLibSize)
    data_transformed <- as.data.frame(apply(data_transformed, c(1,2), function(x) log2(x+1)))
  }


  ## PLOTTING TOTAL COUNTS BY SAMPLE ##
  if(!is.null(totalCountsFile)){
    countplots <- .PlotCounts(totalCounts, design[,i, drop=FALSE])
    pdf(paste0(outPath, "/totalCountsBySamplePlots_",colnames(design)[i], ".pdf"))
    for(l in 1:2){print(countplots[[l]])}
    dev.off()
  }

  ## Box and Whisker plots of transformed Spacer counts by gene for each sample ##
  if(geneBoxAndWhiskerPlots) {
    geneSort<-order(-rowSums(data_transformed))
    GeneBoxPlots<-t(data_transformed[geneSort[1:no],])
    GeneBoxPlots<-melt(GeneBoxPlots)
    colnames(GeneBoxPlots)<-c("SampleID", "Gene", "transformed_SpacerCounts")
    GeneBoxPlots[,4]<-0
    colnames(GeneBoxPlots)[4]<-"design"
    for(t in 1:dim(data)[2]) {
      GeneBoxPlots[t,4]<-as.character(design[which(rownames(design)==GeneBoxPlots$SampleID[t]), i])
    }
    GeneBoxPlots[(dim(data)[2]+1):dim(GeneBoxPlots)[1],4]<-as.character(rep(GeneBoxPlots[1:dim(data)[2],4], (dim(GeneBoxPlots)[1]/dim(data)[2])-1))
    GeneBoxPlots$SampleIDs<-as.character(rep(paste0('S',1:dim(data)[2]), dim(GeneBoxPlots)[1]/dim(data)[2]))
    GeneBoxPlots$SampleIDs<-factor(GeneBoxPlots$SampleID, GeneBoxPlots$SampleID[1:dim(data)[2]])
    ggplot(data=GeneBoxPlots, aes(x=SampleIDs,y=transformed_SpacerCounts))+
      geom_boxplot(aes(fill=design))+theme_pub+plot_annotation()+
      xlab("Sample ID") + ylab(paste0(as.character(transformation), " transformed gene-mapping spacer counts"))+ggtitle(paste0(as.character(transformation), " transformed gene-mapping spacer counts for top ", as.character(no), " genes"))+theme(axis.text.x = element_text(angle = 90, hjust = 1))
    ggsave(paste0(outPath, "/GeneBoxPlots_", colnames(design)[i],".pdf"), height = 8.5, width = 10)
  }

  # PCA ##
  if(PCAplots) {
    if(dim(data)[1]<no) {
      no=dim(data)[1]
    }
    sds <- apply(data_transformed, 1, sd)
    o <- order(sds, decreasing = TRUE)
    all_pca<-as.data.frame(t(data_transformed[o[1:no],]))
    all_pca[,no+1]<-as.character(design[,i])
    colnames(all_pca)[no+1]<-colnames(design)[i]
    colnames(all_pca)[1:no]<-1:no
    autoplot(prcomp(all_pca[,1:no]), data = all_pca, size=4, colour = colnames(all_pca)[no+1]) + theme_pub+plot_annotation()+ ggtitle(paste0("PCA plot for top ", as.character(no)," genes sorted by variance")) + scale_size(guide="none")
    ggsave(paste0(outPath, "/PCA_", colnames(design)[i],".pdf"), height = 8.5, width = 10)
    if(clustering){
      autoplot(fanny(all_pca[,1:no], K), data = all_pca, size=4,shape = colnames(all_pca)[no+1], frame = TRUE, frame.type = 'norm') + theme_pub+plot_annotation() + ggtitle(paste0("FANNY clustering for top ", as.character(no)," genes sorted by variance")) + scale_size(guide="none")
      ggsave(paste0(outPath, "/FANNY_", colnames(design)[i],".pdf"), height = 8.5, width = 10)
      set.seed(1)
      autoplot(kmeans(all_pca[,1:no], K), data = all_pca, size=4, shape = colnames(all_pca)[no+1], frame = TRUE, frame.type = 'norm') +  theme_pub+plot_annotation() + ggtitle(paste0("K-means clustering for top ", as.character(no)," genes sorted by variance")) + scale_size(guide="none")
      ggsave(paste0(outPath, "/KMeans_", colnames(design)[i],".pdf"), height = 8.5, width = 10)
    }
  }

  ## DIFFERENTIAL EXPRESSION ##
  if (is.null(designFormula)|is.na(designFormula)) {
    out.de <- .deseq(data, design[,i, drop=FALSE])
    out.er <- .edger(data, design[,i, drop=FALSE])
    out.bs <- .bayseq(data, replicates, design[,i, drop=FALSE])

    # rownames in the result tables as IDs - for consistency
    rownames(out.de) <- out.de$geneID
    rownames(out.er) <- out.er$geneID
    rownames(out.bs) <- out.bs$geneID

    # finding top genes
    top.de <- recoRdseq.filterDEG(out.de, n=20)
    top.er <- recoRdseq.filterDEG(out.er, n=20)
    top.bs <- recoRdseq.filterDEG(out.bs, n=20)
    top.de_pval <- recoRdseq.filterDEG(out.de)
    top.er_pval <- recoRdseq.filterDEG(out.er)
    top.bs_pval <- recoRdseq.filterDEG(out.bs)

    # # union of top 20 genes from DE tools
    union_de[[colnames(design)[i]]] <- union(top.de, union(top.er, top.bs))
    # union of top genes by p value from DE tools
    union_de_pval[[colnames(design)[i]]] <- union(top.de_pval, union(top.er_pval, top.bs_pval))
    # intersect of top genes from DE tools
    intersect_DE[[colnames(design)[i]]] <- intersect(top.de_pval, intersect(top.er_pval, top.bs_pval))

    ## Venn Diagram ##
    if (vennDiagrams){

      pdf(paste0(outPath, "/", "VENN_", colnames(design)[i],".pdf"), width=10, height=10)
      draw.triple.venn(area1 = length(top.de_pval), area2 = length(top.er_pval), area3 = length(top.bs_pval), n12 = length(intersect(top.de_pval,top.er_pval)), n23 = length(intersect(top.er_pval,top.bs_pval)), n13 = length(intersect(top.bs_pval,top.de_pval)),
                       n123 = length(intersect(top.de_pval,intersect(top.er_pval,top.bs_pval))), category = c("DESeq2", "edgeR", "baySeq"),
                       col = FALSE, fill = c("deepskyblue2", "red", "green"), alpha = 0.3)
      dev.off()
    }


    ## Heatmaps ##

    annot_col<-data.frame(as.character(design[,i]))
    rownames(annot_col)=rownames(design)
    colnames(annot_col)=colnames(design)[i]
    colors<-c()
    for(j in 1:length(design[,i])){
      colors<-c(colors, .ggplot2Col(length(unique(design[,i])))[which(unique(design[,i])==design[j,i])])
    }
    colors_corr <- colorRampPalette(rev(brewer.pal(9, "Blues")))(255)
    out_union <-  pheatmap(data_transformed[union_de_pval[[colnames(design)[i]]], ], annotation_col = annot_col, fontsize = 8, fontsize_row = 5, fontsize_col = 7, main = "heatmap for union of DE genes from all tools")
    if(length(intersect_DE[[colnames(design)[i]]])>2) {
      out_intersect<-pheatmap(data_transformed[intersect_DE[[colnames(design)[i]]], ], annotation_col = annot_col, fontsize = 8, fontsize_row = 5, fontsize_col = 7, main = "heatmap for intersect of DE genes from all tools")
    }

    if(length(intersect_DE[[colnames(design)[i]]])>2){
      heatmap<-pheatmap(data_transformed[intersect_DE[[colnames(design)[i]]], ], annotation_col = annot_col, fontsize = 8, fontsize_row = 5, fontsize_col = 7, main = "intersect of significant DE genes (adjusted p-val < 0.05) from all tools")
      .save_pheatmap_pdf(heatmap, paste0(outPath, "/", "heatmaps_intersect_", colnames(design)[i],".pdf"))
      }
    heatmap<-pheatmap(data_transformed[union_de[[colnames(design)[i]]], ], annotation_col = annot_col, fontsize = 8, fontsize_row = 5, fontsize_col = 7, main = "union of top 20 DE genes from all tools")
    .save_pheatmap_pdf(heatmap, paste0(outPath, "/", "heatmaps_union_top20_", colnames(design)[i],".pdf"))
    heatmap<-pheatmap(data_transformed[union_de_pval[[colnames(design)[i]]], ], annotation_col = annot_col, fontsize = 8, fontsize_row = 5, fontsize_col = 7, main = "union of significant DE genes (adjusted p-val < 0.05) from all tools")
    .save_pheatmap_pdf(heatmap, paste0(outPath, "/", "heatmaps_union_", colnames(design)[i],".pdf"))
    heatmap<-pheatmap(data_transformed[o[1:50], ], annotation_col = annot_col, fontsize = 8, fontsize_row = 5, fontsize_col = 7, main = "top 50 genes sorted by variance")
    .save_pheatmap_pdf(heatmap, paste0(outPath, "/", "heatmaps_topvariance_", colnames(design)[i],".pdf"))
    pdf(paste0(outPath, "/", "heatmaps_correlation_", colnames(design)[i],".pdf"))
      heatmap.2(cor(data), trace="none",RowSideColors = as.character(colors), col=colors_corr, ColSideColors = as.character(colors), margins = c(10,10))
      legend("topright", inset=.02, title=colnames(design[i]), legend=unique(design[,i]), fill=.ggplot2Col(length(unique(design[,i]))), cex=0.5)
    dev.off()



    ## write the differential expression results to an output file ##
    out_union<-data.frame(geneID=out_union$tree_row[["labels"]][out_union$tree_row[["order"]]], padj_DESeq2=NA, padj_edgeR=NA, padj_bayseq=NA)
    for(ind in 1:dim(out_union)[1]){
      if(out_union$geneID[ind]%in%out.de$geneID){
        out_union$padj_DESeq2[ind]=out.de$padj[which(out.de$geneID==as.character(out_union$geneID[ind]))]
      }
      if(out_union$geneID[ind]%in%out.er$geneID){
        out_union$padj_edgeR[ind]=out.er$padj[which(out.er$geneID==as.character(out_union$geneID[ind]))]
      }
      if(out_union$geneID[ind]%in%out.bs$geneID){
        out_union$padj_bayseq[ind]=out.bs$padj[which(out.bs$geneID==as.character(out_union$geneID[ind]))]
      }
    }
    if(length(intersect_DE[[colnames(design)[i]]])>2){
      out_intersect<-data.frame(geneID=out_intersect$tree_row[["labels"]][out_intersect$tree_row[["order"]]], padj_DESeq2=NA, padj_edgeR=NA, padj_bayseq=NA)
      for(ind in 1:dim(out_intersect)[1]){
        out_intersect$padj_DESeq2[ind]=out.de$padj[which(out.de$geneID==as.character(out_intersect$geneID[ind]))]
        out_intersect$padj_edgeR[ind]=out.er$padj[which(out.er$geneID==as.character(out_intersect$geneID[ind]))]
        out_intersect$padj_bayseq[ind]=out.bs$padj[which(out.bs$geneID==as.character(out_intersect$geneID[ind]))]
      }
      write.csv(out_intersect,   file=paste0(outPath, "/DEgenes_",colnames(design)[i],"_Intersect_SignatureGenes.csv"))
    }

    write.csv(out.de, file=paste0(outPath, "/", "DEseq_", colnames(design)[i],".csv"))
    write.csv(out.bs, file=paste0(outPath, "/", "baySeq_", colnames(design)[i],".csv"))
    write.csv(out.er, file=paste0(outPath, "/", "edgeR_", colnames(design)[i],".csv"))
    write.csv(out_union,   file=paste0(outPath, "/DEgenes_",colnames(design)[i],"_Union.csv"))
  }
}

if (!is.null(designFormula)&!is.na(designFormula)){
  if(!startsWith(designFormula,"~")) {
    stop("Design formula must start with '~' symbol!")
  }
  if(!isEmpty(grep(":",designFormula))){
    Ratios<-list()
  }
  tempDesign<-strsplit2(designFormula,"+", fixed=TRUE)
  tempDesign[1,1]<-gsub("~", "", tempDesign[1,1], fixed = TRUE)
  SingleElements<-c()
  for(i in 1:dim(tempDesign)[2]) {
    if(isEmpty(grep(":",tempDesign[1,i]))) {
      if(isEmpty(grep(tempDesign[1,i], colnames(design)))) {
        stop("Check design Formula! Only use EXACT colnames from design matrix and don't use symbols except + and :")
      } else {
        SingleElements<-c(SingleElements,tempDesign[1,i])
      }
    } else {
      tempRatioElements<-strsplit2(tempDesign[1,i],":", fixed=TRUE)
      for(m in 1:dim(tempRatioElements)[2]) {
        if(isEmpty(grep(tempRatioElements[1,m], colnames(design)))) {
          stop("Check design Formula! Only use EXACT colnames from design matrix and don't use symbols except + and :")
        } else {
          SingleElements<-c(SingleElements,tempRatioElements[1,m])
        }
      }
    }
    SingleElements<-unique(SingleElements)
  }
  out.de <- .deseq(data, design[,which(colnames(design)%in%SingleElements), drop=FALSE], designFormula)
  out.er <- .edger(data, design[,which(colnames(design)%in%SingleElements), drop=FALSE], designFormula)

  # finding top genes
  top.de <- recoRdseq.filterDEG(out.de, n=30)
  top.er <- recoRdseq.filterDEG(out.er, n=30)
  top.de_pval <- recoRdseq.filterDEG(out.de)
  top.er_pval <- recoRdseq.filterDEG(out.er)

  # union of top genes from DE tools
  union_de <- union(top.de, top.er)
  # intersect of top genes from DE tools
  intersect_DE <- intersect(top.de_pval, top.er_pval)
  union_de_pval <- union(top.er_pval, top.de_pval)

  ## Venn Diagram ##
  if (vennDiagrams){
    pdf(paste0(outPath, "/", "VENN_", designFormula,".pdf"), width=10, height=10)
    draw.pairwise.venn(area1 = length(top.de_pval), area2 = length(top.er_pval),  cross.area = length(intersect(top.de_pval,top.er_pval)), category = c("DESeq2", "edgeR"),
                       col = c("deepskyblue2", "red"))
    dev.off()
  }

  ## Heatmaps ##

  ## Heatmaps ##

  annot_col<-as.data.frame(design[,which(colnames(design)%in%SingleElements), drop=FALSE])
  colors_corr <- colorRampPalette(rev(brewer.pal(9, "Blues")))(255)
  out_union <-  pheatmap(data_transformed[union_de, ], annotation_col = annot_col, fontsize = 8, fontsize_row = 5, fontsize_col = 7, main = "heatmap for union of DE genes from all tools")
  if(length(intersect_DE)>2) {
    out_intersect<-pheatmap(data_transformed[intersect_DE, ], annotation_col = annot_col, fontsize = 8, fontsize_row = 5, fontsize_col = 7, main = "heatmap for intersect of DE genes from all tools")
  }

  if(length(intersect_DE)>2){
    heatmap<-pheatmap(data_transformed[intersect_DE, ], annotation_col = annot_col, fontsize = 8, fontsize_row = 5, fontsize_col = 7, main = "intersect of significant DE genes (adjusted p-val < 0.05) from all tools")
    .save_pheatmap_pdf(heatmap, paste0(outPath, "/", "heatmaps_intersect_", designFormula,".pdf"))
  }
  heatmap<-pheatmap(data_transformed[union_de, ], annotation_col = annot_col, fontsize = 8, fontsize_row = 5, fontsize_col = 7, main = "union of top 20 DE genes from all tools")
  .save_pheatmap_pdf(heatmap, paste0(outPath, "/", "heatmaps_union_top20_", designFormula,".pdf"))
  heatmap<-pheatmap(data_transformed[union_de_pval, ], annotation_col = annot_col, fontsize = 8, fontsize_row = 5, fontsize_col = 7, main = "union of significant DE genes (adjusted p-val < 0.05) from all tools")
  .save_pheatmap_pdf(heatmap, paste0(outPath, "/", "heatmaps_union_", designFormula,".pdf"))
  heatmap<-pheatmap(data_transformed[o[1:50], ], annotation_col = annot_col, fontsize = 8, fontsize_row = 5, fontsize_col = 7, main = "top 50 genes sorted by variance")
  .save_pheatmap_pdf(heatmap, paste0(outPath, "/", "heatmaps_topvariance_", designFormula,".pdf"))
  pdf(paste0(outPath, "/", "heatmaps_correlation_", designFormula,".pdf"))
  heatmap.2(cor(data), trace="none", col=colors_corr,
            margins = c(10,10))
  dev.off()

  ## write the differential expression results to an output file ##

  out_union<-data.frame(geneID=out_union$tree_row[["labels"]][out_union$tree_row[["order"]]], padj_DESeq2=NA, padj_edgeR=NA)
  for(ind in 1:dim(out_union)[1]){
    if(out_union$geneID[ind]%in%out.de$geneID){
      out_union$padj_DESeq2[ind]=out.de$padj[which(out_union$geneID[ind]==out.de$geneID)]
    }
    if(out_union$geneID[ind]%in%out.er$geneID){
      out_union$padj_edgeR[ind]=out.er$padj[which(out_union$geneID[ind]==out.er$geneID)]
    }
  }
  if(length(intersect_DE)>2){
    out_intersect<-data.frame(geneID=out_intersect$tree_row[["labels"]][out_intersect$tree_row[["order"]]], padj_DESeq2=NA, padj_edgeR=NA)
    for(ind in 1:dim(out_intersect)[1]){
      out_intersect$padj_DESeq2[ind]=out.de$padj[which(out_intersect$geneID[ind]==out.de$geneID)]
      out_intersect$padj_edgeR[ind]=out.er$padj[which(out_intersect$geneID[ind]==out.er$geneID)]
    }
    write.csv(out_intersect,   file=paste0(outPath, "/DEgenes_",designFormula,"_IntersectSignature.csv"))
  }

  write.csv(out.de, file=paste0(outPath, "/", "DEseq_", designFormula,".csv"))
  write.csv(out.er, file=paste0(outPath, "/", "edgeR_", designFormula,".csv"))
  write.csv(out_union,   file=paste0(outPath, "/DEgenes_",designFormula,"_Union.csv"))
}
}

#' Create descriptive plots for spacers counts and sequences
#'
#' This function takes in a (optional) spacer stats (summaryStats) file, design matrix file, (optional) spacer sequence info files, 
#' and generates descriptive plots at a specified output path. 
#' @param summaryStats path to summaryStats file generated by primary analysis pipeline
#' @param SpacerInfoFiles_Path path to directory containing spacer sequence info files generated by primary analysis pipeline
#' @param designMatrix  path to design matrix file
#' @param outPath output path
#' @export

spacerStats<- function(
summaryStats = NULL,
SpacerInfoFiles_Path=NULL, # directory containing spacer info files generated during spacer extraction
outPath="/path/for/output",
designMatrix = "path/to/designMatrix"
)
{
if(!dir.exists(outPath)){dir.create(outPath)}

design <- as.data.frame(read_excel(designMatrix))
rownames(design) <- design[,1]
design <- design[,-1, drop=FALSE]

## Reading in stats files and pre-processing them

if(!is.null(summaryStats)){
  stats<-as.data.frame(read.delim(summaryStats, header = TRUE, sep="\t"))
  rownames(stats)<-stats[,1]
  stats<-stats[,-1]
  stats<-stats[which(rownames(stats)%in%rownames(design)),]
  stats<-stats[match(rownames(design),rownames(stats)),]
  stats$uniqueSpacersPerMillionReads = stats$uniqueSpacers*1000000/stats$totalReads

  ## Looping through the columns of the design matrix and creating spacer plots using summaryStats
  for(i in 1:length(colnames(design))) {
      spacerplots <- .SpacerPlot(stats, design[,i, drop=FALSE])
      pdf(paste0(outPath, "/summarySpacerPlots_",colnames(design)[i], ".pdf"))
      for(l in 1:4){print(spacerplots[[l]])}
      dev.off()
  }
}
## Creating strings for info file paths and reading in info files
if(!is.null(SpacerInfoFiles_Path)){
  summary_filepaths=list.files(path = SpacerInfoFiles_Path, pattern = "*.info.txt")
  summary_files<-list()
  
  for(i in 1: length(summary_filepaths)){
    sampleName=gsub(".info.txt", "", summary_filepaths[i])
    summary_files[[sampleName]]<- read_delim(paste0(SpacerInfoFiles_Path, "/", summary_filepaths[i]),
                                             "\t", escape_double = FALSE, trim_ws = TRUE)
  }
  
  ## Making GC content and spacer length plots for spacer files ##
  
  for(i in 1:length(colnames(design))) {
    
    
    designFactors<-unique(design[,i])
    
    for(df in 1:length(designFactors)){
      GC_content<-c()
      Sequence_Length<-c()
      samples<-rownames(design)[which(design[,i]==designFactors[df])]
      
      for(s in 1:length(samples)){
        GC_content<-c(GC_content,summary_files[[samples[s]]]$GC_content)
        Sequence_Length<-c(Sequence_Length, summary_files[[samples[s]]]$Sequence_Length)
      }
      
      GC_content<-as.data.frame(GC_content)
      Sequence_Length<-as.data.frame(Sequence_Length)
      Sequence_Length_freq<-data.frame(table(Sequence_Length))
      k<-sum(Sequence_Length_freq$Freq)
      Sequence_Length_freq$Freq<-Sequence_Length_freq$Freq*100/k
      
      GC_content_distribution<-data.frame(GC_content=seq(0,99,by=5), frequency=0)
      for(j in 1:20){GC_content_distribution$frequency[j]=as.numeric(length(which(GC_content$GC_content>GC_content_distribution$GC_content[j]&GC_content$GC_content<(GC_content_distribution$GC_content[j]+5))))}
      k = sum(GC_content_distribution$frequency)
      GC_content_distribution$frequency<-GC_content_distribution$frequency*100/k
      
      ggplot(GC_content_distribution, aes(x=GC_content, y=frequency))+
        geom_bar(stat="identity", fill="deepskyblue3")+
        theme_pub+plot_annotation()+
        scale_x_continuous(breaks = seq(0, 100, by = 10))+
        xlab("GC content (%)")+
        ylab("Frequency (%)")+
        geom_vline(aes(xintercept=50), linetype=3)
      ggsave(paste0(outPath,"/SpacerGCcontentDistribution_",colnames(design)[i],"_", designFactors[df], ".pdf"),  height = 8.5, width = 10)
      
      
      ggplot(Sequence_Length_freq, aes(x=Sequence_Length, y=Freq))+
        geom_bar(stat="identity", fill="deepskyblue3")+
        theme_pub+plot_annotation()+
        xlab("Spacer Length")+
        ylab("Frequency (%)")
      ggsave(paste0(outPath,"/SpacerLengthFrequencies_",colnames(design)[i],"_", designFactors[df], ".pdf"),  height = 8.5, width = 10)
    }
  }
}
}


## Function to create spacer plots

.SpacerPlot <- function(stats, design){
SpacerPlots <-data.frame(unique(design))
colnames(SpacerPlots)<-colnames(design)
MeanUniqueSpacers<-c()
MeanUniqueSpacersPerMillionReads<-c()
UniqueSpacerSEs<-c()
UniqueSpacersPerMillionReads_SEs<-c()
MeanUniqueSingleAcquisitions<-c()
UniqueSingleAcquisitionSEs<-c()
MeanUniqueDoubleAcquisitions<-c()
UniqueDoubleAcquisitionSEs<-c()
for(k in 1:dim(SpacerPlots)[1]) {
  MeanUniqueSpacers<-c(MeanUniqueSpacers, mean(stats$uniqueSpacers[which(design[,1]==SpacerPlots[k,1])]))
  MeanUniqueSpacersPerMillionReads<-c(MeanUniqueSpacersPerMillionReads, mean(stats$uniqueSpacersPerMillionReads[which(design[,1]==SpacerPlots[k,1])]))
  UniqueSpacerSEs<-c(UniqueSpacerSEs, sd(stats$uniqueSpacers[which(design[,1]==SpacerPlots[k,1])])/sqrt(dim(SpacerPlots)[1]))
  UniqueSpacersPerMillionReads_SEs<-c(UniqueSpacersPerMillionReads_SEs, sd(stats$uniqueSpacersPerMillionReads[which(design[,1]==SpacerPlots[k,1])])/sqrt(dim(SpacerPlots)[1]))
  MeanUniqueSingleAcquisitions<-c(MeanUniqueSingleAcquisitions, mean(stats$uniqueSingleAcquisitions[which(design[,1]==SpacerPlots[k,1])]))
  UniqueSingleAcquisitionSEs<-c(UniqueSingleAcquisitionSEs, sd(stats$uniqueSingleAcquisitions[which(design[,1]==SpacerPlots[k,1])])/sqrt(dim(SpacerPlots)[1]))
  MeanUniqueDoubleAcquisitions<-c(MeanUniqueDoubleAcquisitions, mean(stats$uniqueDoubleAcquisitions[which(design[,1]==SpacerPlots[k,1])]))
  UniqueDoubleAcquisitionSEs<-c(UniqueDoubleAcquisitionSEs, sd(stats$uniqueDoubleAcquisitions[which(design[,1]==SpacerPlots[k,1])])/sqrt(dim(SpacerPlots)[1]))
}
SpacerPlots$MeanUniqueSpacers<-MeanUniqueSpacers
SpacerPlots$MeanUniqueSpacersPerMillionReads<-MeanUniqueSpacersPerMillionReads
SpacerPlots$UniqueSpacerSEs<-UniqueSpacerSEs
SpacerPlots$UniqueSpacersPerMillionReads_SEs<-UniqueSpacersPerMillionReads_SEs
SpacerPlots$MeanUniqueSingleAcquisitions<-MeanUniqueSingleAcquisitions
SpacerPlots$UniqueSingleAcquisitionSEs<-UniqueSingleAcquisitionSEs
SpacerPlots$MeanUniqueDoubleAcquisitions<-MeanUniqueDoubleAcquisitions
SpacerPlots$UniqueDoubleAcquisitionSEs<-UniqueDoubleAcquisitionSEs
SpacerPlots[is.na(SpacerPlots)]=0


spacerplots<-list()
spacerplots[[1]]<-ggplot(SpacerPlots, aes(y=MeanUniqueSpacers, x=as.character(SpacerPlots[,1])))+
  geom_bar(stat="identity", width=0.3,  fill="deepskyblue3")+
  coord_cartesian(ylim = c(0, 1.5*max(SpacerPlots$MeanUniqueSpacers))) + theme_pub+plot_annotation()+
  geom_errorbar(ymin=MeanUniqueSpacers-UniqueSpacerSEs, ymax=MeanUniqueSpacers+UniqueSpacerSEs,linetype=5, width = 0.1, color="darkblue" )+
  xlab(colnames(design)[1]) + ylab("Mean Unique spacers")
spacerplots[[2]]<-ggplot(SpacerPlots, aes(y=MeanUniqueSingleAcquisitions, x=as.character(SpacerPlots[,1])))+
  geom_bar(stat="identity", width=0.3,  fill="deepskyblue3")+
  coord_cartesian(ylim = c(0, 1.5*max(SpacerPlots$MeanUniqueSingleAcquisitions))) + theme_pub+plot_annotation()+
  geom_errorbar(ymin=MeanUniqueSingleAcquisitions-UniqueSingleAcquisitionSEs, ymax=MeanUniqueSingleAcquisitions+UniqueSingleAcquisitionSEs,linetype=5, width = 0.1, color="darkblue" )+
  xlab(colnames(design)[1]) + ylab("Mean unique single acquisitions")
spacerplots[[3]]<-ggplot(SpacerPlots, aes(y=MeanUniqueDoubleAcquisitions, x=as.character(SpacerPlots[,1])))+
  geom_bar(stat="identity", width=0.3,  fill="deepskyblue3")+
  coord_cartesian(ylim = c(0, 1.5*max(SpacerPlots$MeanUniqueDoubleAcquisitions))) + theme_pub+plot_annotation()+
  geom_errorbar(ymin=MeanUniqueDoubleAcquisitions-UniqueDoubleAcquisitionSEs, ymax=MeanUniqueDoubleAcquisitions+UniqueDoubleAcquisitionSEs,linetype=5, width = 0.1, color="darkblue" )+
  xlab(colnames(design)[1]) + ylab("Mean Unique Double acquisitions")
spacerplots[[4]]<-ggplot(SpacerPlots, aes(y=MeanUniqueSpacersPerMillionReads, x=as.character(SpacerPlots[,1])))+
  geom_bar(stat="identity", width=0.3,  fill="deepskyblue3")+
  coord_cartesian(ylim = c(0, 1.5*max(SpacerPlots$MeanUniqueSpacersPerMillionReads))) + theme_pub+plot_annotation()+
  geom_errorbar(ymin=MeanUniqueSpacersPerMillionReads-UniqueSpacersPerMillionReads_SEs, ymax=MeanUniqueSpacersPerMillionReads+UniqueSpacersPerMillionReads_SEs,linetype=5, width = 0.1, color="darkblue" )+
  xlab(colnames(design)[1]) + ylab("Mean Unique spacers per million sequencing reads")
spacerplots
}


